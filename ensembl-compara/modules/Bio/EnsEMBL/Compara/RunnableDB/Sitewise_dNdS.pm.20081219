#
# You may distribute this module under the same terms as perl itself
#
# POD documentation - main docs before the code

=pod 

=head1 NAME

Bio::EnsEMBL::Compara::RunnableDB::Sitewise_dNdS

=cut

=head1 SYNOPSIS

my $db            = Bio::EnsEMBL::Compara::DBAdaptor->new($locator);
my $sitewise_dNdS = Bio::EnsEMBL::Compara::RunnableDB::Sitewise_dNdS->new
  (
   -db         => $db,
   -input_id   => $input_id,
   -analysis   => $analysis
  );
$sitewise_dNdS->fetch_input(); #reads from DB
$sitewise_dNdS->run();
$sitewise_dNdS->output();
$sitewise_dNdS->write_output(); #writes to DB

=cut


=head1 DESCRIPTION

This Analysis/RunnableDB is designed to take a ProteinTree or subtree
as input. This must already have a multiple alignment and a genetree
run on it. It uses the alignment and tree as input into the SLR
program which then generates annotations for the codons/peptides and
the branches in the genetree.

input_id/parameters format eg: "{'protein_tree_id'=>1234}"
    protein_tree_id : use 'id' to fetch a cluster from the ProteinTree

=cut


=head1 CONTACT

  Contact Albert Vilella on module implementation/design detail: avilella@ebi.ac.uk
  Contact Ewan Birney on EnsEMBL in general: birney@sanger.ac.uk

=cut


=head1 APPENDIX

The rest of the documentation details each of the object methods. 
Internal methods are usually preceded with a _

=cut


package Bio::EnsEMBL::Compara::RunnableDB::Sitewise_dNdS;

use strict;
use Getopt::Long;
use IO::File;
use File::Basename;
use Time::HiRes qw(time gettimeofday tv_interval);

use Bio::EnsEMBL::DBSQL::DBAdaptor;
use Bio::EnsEMBL::Compara::DBSQL::DBAdaptor;

use Bio::AlignIO;
use Bio::TreeIO;
use Bio::SimpleAlign;

use Cwd;

use Bio::EnsEMBL::Hive;
our @ISA = qw(Bio::EnsEMBL::Hive::Process);


=head2 fetch_input

    Title   :   fetch_input
    Usage   :   $self->fetch_input
    Function:   Fetches input data for repeatmasker from the database
    Returns :   none
    Args    :   none

=cut


sub fetch_input {
  my( $self) = @_;

  $self->check_job_fail_options;
  $self->throw("No input_id") unless defined($self->input_id);

  #create a Compara::DBAdaptor which shares the same DBI handle
  #with the Pipeline::DBAdaptor that is based into this runnable
  $self->{'comparaDBA'} = Bio::EnsEMBL::Compara::DBSQL::DBAdaptor->new
    (
     -DBCONN=>$self->db->dbc
    );

  # First get the global analysis parameters
  $self->get_params($self->parameters);

  # Get the per-job input parameters. Note that any duplicate keys will override the analysis-wide parameter from the above call.
  $self->get_params($self->input_id);

  $self->print_params if($self->debug);
  $self->check_if_exit_cleanly;
  
  ### DEFAULT PARAMETERS ###
  my $p = '';

  $p = 'split_saturated_trees';
  $self->{$p} = 0 unless (defined $self->{$p});
  $p = 'output_table';
  $self->{$p} = 'sitewise_aln_dummy' unless (defined $self->{$p});
  $p = 'mask_type';
  $self->{$p} = 'none' unless (defined $self->{$p});
  $p = 'mask_param';
  $self->{$p} = '' unless (defined $self->{$p});

  $p = 'gencode';
  $self->{$p} = 'universal' unless (defined $self->{$p});
  $p = 'saturated';
  $self->{$p} = 100 unless (defined $self->{$p});
  #########################

  ### EARLY EXIT IF THE TREE AINT RIGHT ###
  $p = 'protein_tree';
  throw "undefined ProteinTree as input!\n" unless (defined $self->{$p});
  my $num_leaves = $self->{$p}->num_leaves;
  if ($num_leaves < 4) {
      $self->{'protein_tree'}->release_tree;
      $self->{'protein_tree'} = undef;
      throw "Sitewise_dNdS : cluster size under 4, FAIL THE JOB!!!";
  }
  #########################

  ### LOAD UP THE CODON ALIGNMENT AND NEWICK FORMAT ###
  $p = 'cdna';
  $self->{$p} = $self->{'protein_tree'}->get_SimpleAlign(-cdna => 1);
  $p = 'newick';
  $self->{$p} = $self->{'protein_tree'}->newick_format("int_node_id");
  #########################

  $self->{'protein_tree'}->print_tree(10) if ($self->debug);
  return 1;
}


=head2 run

    Title   :   run
    Usage   :   $self->run
    Function:   runs SLR
    Returns :   none
    Args    :   none

=cut


sub run {
  my $self = shift;
  $self->check_if_exit_cleanly;
  $self->run_sitewise_dNdS;
}


=head2 write_output

    Title   :   write_output
    Usage   :   $self->write_output
    Function:   stores SLR annotations
    Returns :   none
    Args    :   none

=cut


sub write_output {
  my $self = shift;

  unless (defined($self->{results})) {
    $self->input_job->update_status('FAILED');
    return undef;
  }

  $self->check_if_exit_cleanly;

  my $results = $self->{'results'};

  if (defined($results->{'max_dS'})) {
      # Store the max branchwise dS in the database.
      $self->{'protein_tree'}->store_tag('Sitewise_dNdS_max_dS', $results->{'max_dS'});

      print " --> SATURATED!\n" if ($self->debug);

      # Decide whether or not to split the tree into new jobs.
      if ($self->{'split_saturated_trees'}) {
	  # We've decided to split the saturation.

	  # TODO: fix all this.
	  # Create another job for each subtree.
	  # We do this by finding the node_id appropriate for each 
	  if (defined($results->{'trees'}))
	  {
	      my $pta = $self->{'comparaDBA'}->get_ProteinTreeAdaptor;
	      foreach my $subtree_num (keys %{$results->{'trees'}})
	      {
		  my $subtree = $self->{'results'}{'trees'}->{$subtree_num};
		  
		  #my $output_id = sprintf("{'protein_tree_id'=>%d, 'clusterset_id'=>1}", $subroot);
		  #$self->input_job->input_id($output_id);
		  #$self->dataflow_output_id($output_id, 2);
	      }
	  }
	  $self->input_job->update_status('FAILED');
	  #$self->input_job->print_job() if ($self->debug);
	  $self->{'protein_tree'}->release_tree;
	  $self->{'protein_tree'} = undef;
	  warn("### Sitewise_dNdS.pm: cluster saturated, creating jobs for subtrees and FAIL it");
	  return undef;
      } else {
	  # We've decided to ignore saturation, so we're gonna run SLR again with an artificially high saturated parameter.

	  print " --> Splitting trees is OFF, so run again with higher saturation value!\n";
	  $self->{'saturated'} = 100;
	  $self->run();
	  $self->write_output();
      }
  } elsif (defined($results->{'sites'})) {
      $self->store_sitewise_dNdS;
  } else {
      # something wrong went on
      $self->{'protein_tree'}->release_tree;
  }
}


sub DESTROY {
  my $self = shift;

  if ($self->{'protein_tree'}) {
    printf("Sitewise_dNdS::DESTROY  releasing tree\n") if($self->debug);
    $self->{'protein_tree'}->release_tree;
    $self->{'protein_tree'} = undef;
  }

  $self->SUPER::DESTROY if $self->can("SUPER::DESTROY");
}


##########################################
#
# internal methods
#
##########################################

sub _create_job_for_tree {
    my $self = shift;
    my $treeI = shift;

    my @nodes;
    foreach my $node ($treeI->get_nodes) {  # Remember: we're using the TreeI interface here!
	if ($node->is_Leaf) {
	    push @nodes, $node->id;
	}
    }
    my $members_hash;
    foreach my $node (@nodes) {
	$node =~ s/\s+//;
	$members_hash->{$node} = 1;
    }
    
    # Load up a copy of our tree
    my $pta = $self->{'comparaDBA'}->get_ProteinTreeAdaptor;
    my $partial_tree = $pta->fetch_node_by_node_id($self->{'protein_tree'}->node_id);
    
    # Collapse to only contain the members within the SLR-defined subtree.
    foreach my $leaf (@{$partial_tree->get_all_leaves}) {
	next if (defined($members_hash->{$leaf->stable_id}));
	$leaf->disavow_parent;
	$partial_tree = $partial_tree->minimize_tree;
    }
    my $subroot = $partial_tree->node_id;  # Grab the node_id at the root of this collapsed tree.
    $partial_tree->release_tree;
    
    printf "Current node ID: %s, subtree ID: %s\n", $self->{'protein_tree'}->node_id, $subroot;

    # BIG QUESTION: What to do here when the subroot ID is the same as the current node ID? This means
    # that an "internal" branch was saturated, not one of the branches coming off of the whole tree.

    # One solution: create a new job with the same node_id, but with a new flag that forces us to store the results.

    #next if ($self->{'protein_tree'}->node_id == $subroot);  # If this subtree is the same as the full one, skip it.
    #next if ($partial_tree->num_leaves >= $self->{'protein_tree'}->num_leaves);  # What exactly does this tell us?
    
    my $tree = $pta->fetch_node_by_node_id($subroot);
    print sprintf(" --> New subtree: %s %s\n",$subroot,$tree->newick_format());
    
    # Create a new job with the new node ids.
    my $input_id = $self->input_id;
    my $cur_node_id = $self->{'protein_tree'}->node_id;
    $input_id =~ s/$cur_node_id/$subroot/;
    printf " --> New input_id: %s \n",$input_id;
    
    my $aja = $self->input_job->adaptor;
    
    my $new_job_id = $aja->CreateNewJob
	( -input_id => $input_id,
	  -analysis => $self->analysis,
	  -input_job_id => $self->input_job->dbID
	  );
    
    printf("New job id: %s",$new_job_id);
}

sub get_params {
  my $self         = shift;
  my $param_string = shift;

  return unless($param_string);
  print("parsing parameter string : ",$param_string,"\n") if($self->debug);

  # Turn the given param string into a hashref.
  my $params = eval($param_string);
  return unless($params);

  if (defined($params->{'protein_tree_id'})) {
      my $pta = $self->{'comparaDBA'}->get_ProteinTreeAdaptor();
      $self->{'protein_tree'} = $pta->fetch_node_by_node_id($params->{'protein_tree_id'});

      # GJ 2008-10-21: Allow for different input tables.
      if (defined($params->{'input_table'})) {
	  $self->{'input_table'} = $params->{'input_table'};
	  # We've got an alternate member table, so let's grab the cigar line from there.
	  my $tree = $self->{'protein_tree'};
	  my $table = $params->{'input_table'};
	  
	  foreach my $leaf (@{$tree->get_all_leaves}) {
	      # "Release" the stored / cached values for the alignment strings.
	      undef $leaf->{'cdna_alignment_string'};
	      undef $leaf->{'alignment_string'};
	      
	      # Grab the correct cigar line for each leaf node.
	      my $id = $leaf->member_id;
	      my $cmd = "SELECT cigar_line FROM $table where member_id=$id;";
	      my $sth = $pta->prepare($cmd);
	      $sth->execute();
	      my $data = $sth->fetchrow_hashref();
	      $sth->finish();
	      my $cigar = $data->{'cigar_line'};

	      throw "No cigar line for member $id!\n" unless ($cigar);
	      $leaf->cigar_line($cigar);
	  }
      }
  }

  my $p = '';

  # MASK_TYPE: the type of masking to be applied before sending the alignments over to SLR.
  # Could be: none, gblocks, or t_coffee.
  $p = 'mask_type';
  $self->{$p} = $params->{$p} if (defined($params->{$p}));
  
  # MASK_PARAM: a parameter for the chosen type of masking.
  # For t_coffee, this is the threshold score, below which sequences are masked.
  # For gblocks, this is ... ???
  $p = 'mask_param';
  $self->{$p} = $params->{$p} if (defined($params->{$p}));

  # SPLIT_SATURATED_TREES: whether or not to split saturated trees into two subtrees.
  $p = 'split_saturated_trees';
  $self->{$p} = $params->{$p} if (defined($params->{$p}));

  # INPUT_TABLE: the table from which to retrieve alignments.
  $p = 'input_table';
  $self->{$p} = $params->{$p} if (defined($params->{$p}));

  # OUTPUT_TABLE: the table to send SLR output to.
  $p = 'output_table';
  $self->{$p} = $params->{$p} if (defined($params->{$p}));

  # GENCODE: the genetic code to use for SLR.
  # Options: 'universal' or 'mammalian' mitochondrial.
  $p = 'gencode';
  $self->{$p} = $params->{$p} if (defined($params->{$p}));

  # SATURATED: the lavel at which to signal a dS-saturated tree.
  # (We've found that somewhere between 1.5-2.0 works well)
  $p = 'saturated';
  $self->{$p} = $params->{$p} if (defined($params->{$p}));

  return;
}


sub print_params {
  my $self = shift;

  print("params:\n");
  print("  tree_id   : ", $self->{'protein_tree'}->node_id,"\n") if($self->{'protein_tree'});
}


sub run_sitewise_dNdS
{
  my $self = shift;

  print ("Sitewise_dNdS::run_sitewise_dNdS\n") if ($self->debug);

  return undef unless (defined($self->{protein_tree}));
  $self->{starttime} = time()*1000;

  my $slrexe = $self->{'slr_executable'};
  unless (-e $slrexe) {
    $slrexe = "/software/ensembl/compara/bin/Slr_ensembl";
  }

  throw("can't find an slr executable to run\n") 
    unless(-e $slrexe);

  my $aln = $self->{'cdna'};
  my $tree_string = $self->{'newick'};

  open(my $fake_fh, "+<", \$tree_string);
  my $treein = new Bio::TreeIO
    (-fh => $fake_fh,
     -format => 'newick');
  my $tree = $treein->next_tree;
  $treein->close;
  throw("can't find cds_aln\n") if ( ! $aln );
  throw("can't find tree\n") if ( ! $tree );

  # Reorder the alignment according to the tree
  my $sorted_aln = $aln->sort_by_tree($tree);

  # Get the number of leaf nodes.
  my $ct = 1;
  foreach my $node ($tree->get_leaf_nodes) {
      $ct++;
  }

  # Mask the aligment
  my $mask_type = $self->{'mask_type'};
  my $mask_param = $self->{'mask_param'};

  foreach my $seq ($sorted_aln->each_seq) {
      print substr($seq->id,0,8)."\t".substr($seq->seq,0,100)."\n";
  }

  if ($mask_type eq 'gblocks') {
      print " --> MASKING: gblocks, $mask_param\n" if ($self->debug);
      $sorted_aln = $self->mask_gblocks($mask_param,$sorted_aln);
  } elsif ($mask_type eq 't_coffee') {
      print " --> MASKING: t_coffee, $mask_param\n" if ($self->debug);
      $sorted_aln = $self->mask_t_coffee_nuc($mask_param,$sorted_aln);
  } else {
      # No masking.
      print " --> MASKING: none\n" if ($self->debug);
  }

  foreach my $seq ($sorted_aln->each_seq) {
      print substr($seq->id,0,8)."\t".substr($seq->seq,0,100)."\n";
  }

  my $tmpdir = $self->worker_temp_directory;
  my $alnout = Bio::AlignIO->new
    ('-format'      => 'phylip',
     '-file'          => ">$tmpdir/aln",
     '-interleaved' => 0,
     '-idlinebreak' => 1,
     '-idlength'    => $aln->maxdisplayname_length + 1);
  $alnout->write_aln($sorted_aln);
  $alnout->close();
  undef $alnout;

  my $treeout = Bio::TreeIO->new('-format' => 'newick',
                                 '-file'     => ">$tmpdir/tree");
  # We need to add a line with the num of leaves ($ct-1) and the
  # num of trees (1)
  $treeout->_print(sprintf("%d 1\n",($ct-1)));
  $treeout->write_tree($tree);
  $treeout->close();

  # now let's print the ctl file.
  # many of the these programs are finicky about what the filename is 
  # and won't even run without the properly named file.
  my $slr_ctl = "$tmpdir/slr.ctl";
  open(SLR, ">$slr_ctl") or $self->throw("cannot open $slr_ctl for writing");
  print SLR "seqfile\: aln\n";
  print SLR "treefile\: tree\n";
  my $outfile = "slr.res";
  print SLR "outfile\: $outfile\n";
  print SLR "saturated\: ". $self->{'saturated'} . "\n";
  print SLR "gencode\: ". $self->{'gencode'} . "\n";
  print SLR "aminof\: 1\n"; # aminof
  close(SLR);

  my ($rc,$results) = (1);
  {
    my $cwd = cwd();
    my $exit_status;
    chdir($tmpdir);
    my $run;
    my $quiet = '';
    $quiet = ' 2>/dev/null' unless ($self->debug);
    $self->{'comparaDBA'}->dbc->disconnect_when_inactive(1);
    open($run, "$slrexe $quiet |") or $self->throw("Cannot open exe $slrexe");
    my @output = <$run>;
    $exit_status = close($run);
    $self->{'comparaDBA'}->dbc->disconnect_when_inactive(0);
    $self->{error_string} = (join('',@output));

    if ( (grep { /is saturated/ } @output)) {
	print ("  -> Tree is dS saturated!\n") if ($self->debug);

	# Find the highest branchwise dS value.
	my $max = $self->{'saturated'};
	foreach my $line (grep { /is saturated/ } @output) {
	    $line =~ /length = (\S+)/;
	    $max = $1 if ($1 > $max);
	}
	$results->{'max_dS'} = sprintf("%2.3f",$max);
	$results->{'trees'} = {};
	if (-e "$tmpdir/subtrees.out") {
	    my $treeio = Bio::TreeIO->new
		('-format' => 'newick',
		 '-file'   => "$tmpdir/subtrees.out");
	    my $tree_num= 1;
	    while ( my $tree = $treeio->next_tree ) {
		print "  SAT SUBTREE: $tree_num\n";
		$results->{'trees'}->{$tree_num} = $tree;
		$tree_num++;
	    }
	}
	chdir($cwd);
	$self->{'results'} = $results;
	$self->{'rc'} = $rc;
	return undef;
    }
    
    foreach my $outline (@output) {
      if ($outline =~ /lnL = (\S+)/) {
        $results->{'lnL'} = $1;
      }
      if ($outline =~ /kappa = (\S+)/) {
        $results->{'kappa'} = $1;
      }
      if ($outline =~ /omega = (\S+)/) {
        $results->{'omega'} = $1;
      }
    }
    if ( (grep { /\berr(or)?: /io } @output)  || !$exit_status) {
      warn("There was an error - see error_string for the program output");
      $rc = 0;
    }
    eval {
      open RESULTS, "$tmpdir/$outfile" or die "couldnt open results file: $!\n";
      my $okay = 0;
      my $sites;
      my $type = 'default';
      while (<RESULTS>) {
        chomp $_;
	print $_."\n";
        if ( /^\#/ ) {
          next;
        }
        if ( /\!/ ) {
          $type = 'random';  # random is last
        } elsif ( /Constant/ ) {
          $type = 'constant';
        } elsif ( /All gaps/ ) {
          $type = 'all_gaps';
        } elsif ( /Single char/ ) {
          $type = 'single_char';
        } elsif ( /Synonymous/ ) {
          $type = 'synonymous';
        } elsif ( /\+\+\+\+\s+/ ) {
          $type = 'positive4';
        } elsif ( /\+\+\+\s+/ ) {
          $type = 'positive3';
        } elsif ( /\+\+\s+/ ) {
          $type = 'positive2';
        } elsif ( /\+\s+/ ) {
          $type = 'positive1';
        } elsif ( /\-\-\-\-\s+/ ) {
          $type = 'negative4';
        } elsif ( /\-\-\-\s+/ ) {
          $type = 'negative3';
        } elsif ( /\-\-\s+/ ) {
          $type = 'negative2';
        } elsif ( /\-\s+/ ) {
          $type = 'negative1';
        } else {
          $type = 'default';
        }
        if ( /^\s+(\d+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)/ ) {
          push @{$sites->{$type}}, [$1,$2,$3,$4,$5,$6,$7,$8,$9];
        } else {
          warn("error parsing the results: $_\n");
        }
      }
      $results->{'sites'} = $sites;
      close RESULTS;
    };
    if ( $@ ) {
      warn($self->{error_string});
    }
    chdir($cwd);
  }

  $self->{'results'} = $results;
  $self->{'rc'} = $rc;

  return undef;
}


sub check_job_fail_options
  {
    my $self = shift;

    if ($self->input_job->retry_count >= 2) {
      $self->dataflow_output_id($self->input_id, 2);
      $self->input_job->update_status('FAILED');

      if ($self->{'protein_tree'}) {
        $self->{'protein_tree'}->release_tree;
        $self->{'protein_tree'} = undef;
      }
      throw("Sitewise_dNdS job failed >=3 times: try something else and FAIL it");
    }
  }


sub mask_t_coffee_aa
{
    my $self = shift;
    $self->_mask_t_coffee(@_,0);
}

sub mask_t_coffee_nuc
{
    my $self = shift;
    $self->_mask_t_coffee(@_,1);
}


sub _mask_t_coffee
{
    my $self = shift;
    my $threshold = shift;
    my $cdna_aln = shift;
    my $nucleotide = shift;

    # Collect the hash_ref of score strings from the database.
    my $table = $self->{'input_table'};
    my $score_table = $table . '_score';
    my $tree = $self->{'protein_tree'};
    
    my $pta = $self->{'comparaDBA'}->get_ProteinTreeAdaptor;

    my $hash_ref;
    foreach my $leaf (@{$tree->get_all_leaves}) {
	# Grab the score line for each leaf node.
	my $id = $leaf->stable_id; # Must be stable_id to match the aln object.
	my $member_id = $leaf->member_id;
	my $cmd = "SELECT cigar_line FROM $score_table where member_id=$member_id;";
	my $sth = $pta->prepare($cmd);
	$sth->execute();
	my $data = $sth->fetchrow_hashref();
	$sth->finish();
	my $cigar = $data->{'cigar_line'};

	#print $id."\t".$cigar ."\n";

	# Convert the protein mask into a DNA-level mask by repeating each char 3 times.
	my @arr = split(//,$cigar);
	if ($nucleotide)
	{
	    @arr = map { ($_ . '') x 3 } @arr;
	}
	$cigar = join("",@arr);
	$hash_ref->{$id} = $cigar;
    }
    my $new_aln = $cdna_aln->mask_below_score($threshold,$hash_ref);
    return $new_aln;
}


sub mask_gblocks
  {
    my $self = shift;
    my $gmin = shift;
    my $aln  = shift;

    printf("Sitewise_dNdS::run_gblocks\n") if($self->debug);

    throw("Sitewise_dNdS : error getting Peptide SimpleAlign") unless (defined($aln));

    my $aln_length = $aln->length;
    my $tree_id = $self->{'protein_tree'}->node_id;
    my $tmpdir = $self->worker_temp_directory;
    my $filename = "$tmpdir". "$tree_id.fasta";
    my $tmpfile = Bio::AlignIO->new
      (-file => ">$filename",
       -format => 'fasta');
    $tmpfile->write_aln($aln);
    $tmpfile->close;
    my $min_leaves_gblocks = int(($self->{'protein_tree'}->num_leaves+1) * $gmin + 0.5);
    my $cmd = "echo -e \"o\n$filename\n\nb\n2\n$min_leaves_gblocks\n5\n5\ng\nm\nq\n\" | /software/ensembl/compara/bin/Gblocks 2>/dev/null 1>/dev/null";
    my $ret = system("$cmd");
    open FLANKS, "$filename-gb.htm" or die "$!\n";
    my $segments_string;
    while (<FLANKS>) {
      chomp $_;
      next unless ($_ =~ /Flanks/);
      $segments_string = $_;
      last;
    }
    close FLANKS;
    $segments_string =~ s/Flanks\: //g;
    $segments_string =~ s/\s+$//g;

    $self->{flanks} = $segments_string;
    $self->{'protein_tree'}->store_tag('Gblocks_flanks', $segments_string);
  }


sub store_sitewise_dNdS
{
  my $self = shift;

  printf("Sitewise_dNdS::store_sitewise_dNdS\n") if($self->debug);

  my $runtime = time()*1000-$self->{starttime};
  $self->{'protein_tree'}->store_tag('Sitewise_dNdS_runtime_msec', $runtime);

  my $results = $self->{'results'};
  my $aa_aln = $self->{'protein_tree'}->get_SimpleAlign;
  
  # Mask the alignment as before, except now it's AAs insetad of Nucs.
  my $mask_type = $self->{'mask_type'};
  my $mask_param = $self->{'mask_param'};

  if ($mask_type eq 'gblocks') {
      print " --> MASKING: gblocks, $mask_param\n" if ($self->debug);
      $aa_aln = $self->mask_gblocks($mask_param,$aa_aln);
  } elsif ($mask_type eq 't_coffee') {
      print " --> MASKING: t_coffee, $mask_param\n" if ($self->debug);
      $aa_aln = $self->mask_t_coffee_aa($mask_param,$aa_aln);
  } else {
      # No masking.
      print " --> MASKING: none\n" if ($self->debug);
  }

  my @gap_col_matrix = @{$aa_aln->gap_col_matrix};
  $self->{memberDBA} = $self->{'comparaDBA'}->get_MemberAdaptor;
  my $root_id = $self->{'protein_tree'}->node_id;

  # We store a tag with the subroot_id so that we can do easy mapping
  # from subtree to root
  my $subroot_id = $self->{'protein_tree'}->subroot->node_id;
  $self->{'protein_tree'}->store_tag('Sitewise_dNdS_subroot_id', $subroot_id);
  my $threshold_on_branch_ds = $self->{'saturated'};

  my $simple_aln = $self->{'protein_tree'}->get_SimpleAlign();
  my $aln_length = $simple_aln->length();

  my %masked_hash = {};
  foreach my $i (0 .. $aln_length) {
      $masked_hash{$i} = 1;
  }

  # Store whether or not each site was gblocks-masked.
  my $mask;
  my $start = 1;
  foreach my $segment ($self->{flanks} =~ /(\[\d+  \d+\])/g) {
      my ($segm_start,$segm_end) = $segment =~ /\[(\d+)  (\d+)\]/;
      print $segment."\n";
      foreach my $i ($segm_start..$segm_end) {
	  $masked_hash{$i} = 0;
      }
  }
#  foreach my $key (sort keys %masked_hash) {
#      print $key . "  ". $masked_hash{$key}."\n";
#  }

  ####

  my $sth;

  foreach my $type (keys %{$results->{sites}}) {
      next if ($type =~ /all_gaps/); # FIXME
      foreach my $position (@{$results->{sites}{$type}}) {
	  # Site  Neutral  Optimal   Omega    lower    upper LRT_Stat    Pval     Adj.Pval    Q-value Result Note
	  # 1     4.77     3.44   0.0000   0.0000   1.4655   2.6626 1.0273e-01 8.6803e-01 1.7835e-02        Constant;
	  # 0     1        2      3        4        5        6      7          8          9
	  my ($site, $neutral, $optimal, $omega, $lower, $upper, $lrt_stat, $pval, $adj_pval, $q_value) = @$position;
	  my $nseq_ngaps = 0; foreach my $val (values %{$gap_col_matrix[$site-1]}) {$nseq_ngaps++ unless (1 == $val)};
	  my $optimalc; if (0 != $nseq_ngaps) {$optimalc = $optimal / $nseq_ngaps;} else {$optimalc = $optimal;}
	  $DB::single=1;1;#??
	      
	      my $table = 'sitewise_aln_dummy';
	  if (defined($self->{'output_table'})) {
	      $table = $self->{'output_table'};
	  }
	  $sth = $self->{'comparaDBA'}->dbc->prepare
	      ("REPLACE INTO $table
                           (aln_position,
                            node_id,
                            tree_node_id,
                            omega,
                            omega_lower,
                            omega_upper,
                            optimal,
                            ncod,
                            threshold_on_branch_ds,
                            type) VALUES (?,?,?,?,?,?,?,?,?,?)");
	  $sth->execute($site,
			$root_id,
			$subroot_id,
			$omega,
			$lower,
			$upper,
			$optimalc,
			$nseq_ngaps,
			$threshold_on_branch_ds,
			$type);
	  $sth->finish();
      }
  }
  
  return undef;
}

1;
