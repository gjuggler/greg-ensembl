RequireVersion ("0.9920060514");/*----------------------------------------------------------------------------------*/function convertMatrixToBranchPart (daModel){	matchedRateAVL = {};	for (k=0; k<Columns(branchNames)-1; k=k+1)	{		nodeRate  = daModel[k];		existingString = matchedRateAVL[nodeRate];		if (Abs(existingString))		{			existingString = existingString+",\""+branchNames[k]+"\"";				}		else		{			existingString = "\""+branchNames[k]+"\"";		}		matchedRateAVL[nodeRate] = existingString;	}	matchedRateKeys = Rows (matchedRateAVL);		convMdlString = "";	convMdlString * 128;	convMdlString * ("Tree theTree = "+Format (analysisTree,1,0) + ";\n_branchClasses={};\n");		for (k=0; k<Abs(matchedRateAVL); k=k+1)	{		daKey = matchedRateKeys[k];		convMdlString * ("_branchClasses[\""+daKey+"\"]={{"+matchedRateAVL[daKey]+"}};\n");	}		convMdlString * 0;	return convMdlString;}/*----------------------------------------------------------------------------------*/branchLabels = {};SetDialogPrompt ("Please locate the output of a GA branch analysis:");fscanf 			(PROMPT_FOR_FILE, "Raw", inFile);fprintf 		(stdout, "\n[PHASE 0] Processing ", LAST_FILE_PATH, "\n");SetDialogPrompt ("Save HTML results to");fprintf			(PROMPT_FOR_FILE, CLEAR_FILE, KEEP_OPEN,				"<!DOCTYPE HTML PUBLIC '-//W3C//DTD HTML 4.01 Transitional//EN'><html><head><meta http-equiv='Content-Type' content='text/html; charset=ISO-8859-1'><title>GA Branch Selection Results</title><LINK REL=STYLESHEET TYPE=\"text/css\" HREF=\"http://www.hyphy.org/styles\"></head><body>");fPath 			= LAST_FILE_PATH;fName			= fPath;sscanf			(inFile,"Tree",analysisTree);branchCount 	= TipCount (analysisTree) + BranchCount (analysisTree);branchNames 	= BranchName (analysisTree,-1);fprintf			(fName, "<H1 class = 'SuccessCap'>GA Branch Selection Results</H1>\n");modelScores    = {};branchMatrices = {};fprintf (stdout, "[PHASE 1] Reading raw data\n");while (!END_OF_FILE){	branchRates = 0;	sscanf (inFile, "Number,NMatrix", maic, branchRates);	if (Abs(branchRates) == 0)	{		break;	}	modelScores		[Abs(modelScores)] 		= maic;	branchMatrices	[Abs(branchMatrices)] 	= branchRates;}inFile 			= 0;modelCount 		= Abs(modelScores);fprintf (stdout, "\tRead ", modelCount, " model fits\n");bestAIC	   		= 1e100;modelAICs  		= {modelCount,1};branchRates 	= {branchCount, modelCount}["1"];byRate 		     = {};bestAICByRate    = {};bestRateByClass  = {};rateCountByModel = {1,modelCount};fprintf (stdout, "\n[PHASE 2] Tabulating Rates\n");for (h=0; h<modelCount; h=h+1){	maic 			= modelScores[h];	branchMatrix 	= branchMatrices[h];		if (maic<bestAIC)	{		bestAIC 	= 	maic;		bestModel 	= 	branchMatrix;	}		rateAVL = {};	for (v2=0; v2<branchCount;v2=v2+1)	{		branchRates[v2][h]        = branchMatrix[v2];		rateAVL[branchMatrix[v2]] = rateAVL[branchMatrix[v2]]+1;	}		rateC  		 = Abs(rateAVL);	if (bestAICByRate[rateC] == 0)	{		bestAICByRate[rateC]   = maic;		bestRateByClass[rateC] = rateAVL;	}	else	{		if (maic < bestAICByRate[rateC])		{			bestAICByRate[rateC] = maic;			bestRateByClass[rateC] = rateAVL;		}	}	rateCountByModel [h] = rateC;	byRate 		 [rateC] = byRate [rateC] + 1;	modelAICs[h] 		 = maic;}fprintf (stdout, "\tBest overall c-AIC      = ", bestAIC);for (h=1; h<=Abs (byRate); h=h+1){	fprintf    (stdout, "\n\tBest c-AIC with ", h, " rates = ", Format(bestAICByRate[h],8,3), ". Rate estimates (branches): "); 	rts = Rows (bestRateByClass[h]);	for (h2 = 0; h2 < h; h2=h2+1)	{		fprintf (stdout, Format (0+rts[h2],9,4), " (", Format((bestRateByClass[h])[rts[h2]],4,0), ")");	}}fprintf (stdout, "\n\n[PHASE 3] Computing Akaike Weights and Model Averaged Rate Estimates\n");sAICs = modelAICs;modelScores    = 0;branchMatrices = 0;normalizer = 0;for (h=0; h<modelCount; h=h+1){	modelAICs[h] = Exp(-(modelAICs[h]-bestAIC)*0.5);	normalizer   = normalizer+modelAICs[h];}modelAICs = modelAICs * (1/normalizer); summaryMatrix = {branchCount,6};pairwiseSame  = {branchCount,branchCount};overOne		  = {branchCount,1};for (h=0; h<branchCount; h=h+1){	probabilityMatrix = {modelCount,2};		for (v=0; v<modelCount; v=v+1)	{		probabilityMatrix[v][0] = branchRates[h][v];		probabilityMatrix[v][1] = modelAICs[v];	}	probabilityMatrix = probabilityMatrix%0;		sum  = 0;	sum2 = 0;	prob = 0;	r25  = -1;	r975 = -1;	r500	 = -1;	overOne = 0;		for (v=0; v<modelCount; v=v+1)	{		mpp = probabilityMatrix[v][1];		mpv = probabilityMatrix[v][0];				sum  = sum + mpv * mpp;		sum2 = sum2 + mpv^2 * mpp;		prob = prob + mpp;				if (mpv>1)		{			overOne = overOne+mpp;		}				if (prob > 0.025 && r25 < 0)		{			r25 = probabilityMatrix[v][0];		}		if (prob > 0.975 && r975 < 0)		{			r975 = probabilityMatrix[v][0];		}		if (prob >= 0.5 && r500 < 0)		{			r500 = probabilityMatrix[v][0];		}	}		summaryMatrix[h][0] = sum;	summaryMatrix[h][1] = Sqrt(sum2-sum^2);	summaryMatrix[h][2] = r25;	summaryMatrix[h][3] = r975;	summaryMatrix[h][4] = overOne;	summaryMatrix[h][5] = r500;}for (h=0; h<branchCount; h=h+1){	for (v=h+1; v<branchCount; v=v+1)	{		for (v2 = 0; v2 < modelCount; v2 = v2+1)		{			if (branchRates[h][v2] == branchRates[v][v2])			{				pairwiseSame[h][v] = pairwiseSame[h][v] + modelAICs[v2];				pairwiseSame[v][h] = pairwiseSame[h][v];			}		}	}}outString = "";outString * 8192;outString * "Branch Name";for (h=0; h<branchCount; h=h+1){	outString * (","+branchNames[h]);}for (h=1; h<branchCount; h=h+1){	outString * ("\n"+branchNames[h]);	for (h2=0; h2<branchCount; h2=h2+1)	{		outString * (","+pairwiseSame[h][h2]);	}}outString * 0;fName2 = fPath + "_branch_equal.csv";fprintf (fName2, CLEAR_FILE,outString);fprintf (stdout, "\n\n[PHASE 4] Computing Confidence Sets and Generating Result Files\n");probabilityMatrix = {modelCount,2};inCSByRates		  = {};for (v=0; v<modelCount; v=v+1){	probabilityMatrix[v][0] = v;	probabilityMatrix[v][1] = modelAICs[v];}probabilityMatrix = probabilityMatrix % 1;runSum 			  = 0;for (v=modelCount-1; v>=0 && runSum < 0.95; v=v-1){	runSum = runSum + probabilityMatrix[v][1];	inCSByRates [rateCountByModel[probabilityMatrix[v][0]]] = inCSByRates [rateCountByModel[probabilityMatrix[v][0]]] + 1;}csSize = modelCount-v-1;fprintf (stdout, "\tAll models in the 95% confidence set (CS):", Format (csSize, 8,0), "\n",				 "\tHighest c-AIC in the CS: ", Format(sAICs[probabilityMatrix[v+1][0]],8,2));for (h=1; h<=Abs (byRate); h=h+1){	fprintf    (stdout, "\n\tModels in the 95% CS with ", h, " rates = ", Format(inCSByRates[h],6,0)); }fprintf (fName, "<DIV class = 'RepClassSM'><span style = 'font-variant: small-caps; font-size: 24px;'>Analysis summary</span><p>c-AIC scores by class (best score in bold)<p>");htmlAICTable = "";htmlAICTable * 128;htmlAICTable * "<div style = 'width: 580px; border: black solid 1px; '>";htmlAICTable * "<table style = 'width: 100%;font-size: 10px;text-align:left;'><tr><th>Rates</th><th>c-AIC</th><th>&Delta; c-AIC</th><th width = '70%'>dN/dS by class (# branches)</th></tr>";currentAIC = bestAICByRate [1];for (_partCount = 1; _partCount <=Abs (byRate); _partCount = _partCount + 1){	bpLocs2    = bestRateByClass		 [_partCount];	if (_partCount>1)	{		currentAIC = bestAICByRate [_partCount];		ci 		   = bestAICByRate [_partCount-1] - currentAIC;		sp		   = "<table style = 'padding: 0px; spacing: 0px;'><tr>";				rts = Rows (bestRateByClass[_partCount]);		for (k=0; k<Abs (bpLocs2); k=k+1)		{			sp = sp + "<td style = 'font-size:10px;'>" + rts[k] + "(" + bpLocs2[rts[k]] + ")</td>";		}			sp = sp + "</tr></table>";	}	else	{		ci 		   = "";		rts = Rows (bestRateByClass[_partCount]);		sp		   = "<table><tr><td style = 'font-size:10px;width: 406px;'>"+rts[0] + "(" + bpLocs2[rts[0]] + ")</td></tr></table>";	}	if (currentAIC == bestAIC)	{		modS = " style='font-weight: 900; font-size:14px;'";	}	else	{		modS = "";	}	htmlAICTable * ("\n<tr" + modS+ "><td>"+ _partCount+ 						  "</td><td><div style = 'width: "+100*currentAIC/bestAICByRate [1]$1+"%; background-color: purple; color: white;'>"+currentAIC+ 						  "</div></td><td>"+ ci+ 						  "</td><td>"+ sp+						  "</td></tr>");	}htmlAICTable * "\n</table></div>";htmlAICTable * 0;fprintf (fName, htmlAICTable,"<p>95% Confidence Set of Models<p>");htmlAICTable = "";htmlAICTable * 128;htmlAICTable * "<div style = 'width: 580px; border: black solid 1px; '>";htmlAICTable * "<table style = 'width: 100%;font-size: 10px;text-align:left;'><tr style = 'width: 20%'><th>Rates</th><th>Models in 95% CS</th></tr>";for (_partCount = 1; _partCount <=Abs (byRate); _partCount = _partCount + 1){	htmlAICTable * ("<tr><td>" + _partCount + "</td><td>" + inCSByRates[_partCount] + "</td></tr>\n");}htmlAICTable * "\n</table></div>";htmlAICTable * 0;fprintf (fName, htmlAICTable,"</DIV>");/*---------------------------------------------------------------------------------------------------------------------------------------------*/outString = "";outString * 8192;outString2 = "";outString2 * 8192;outString * "Branch Name,Mean,Std.Dev.,2.5%,Median,97.5%,Prob{dN>dS}\n";outString2 * "<TR CLASS = 'TRReport'><TH>Branch Name</TH><TH>Mean</TH><TH>Std.Dev.</TH><TH>2.5%</TH><TH>Median</TH><TH>97.5%</TH><TH>Prob{dN&gt;dS}&#134;</TH></TR>\n";for (h=0; h<branchCount; h=h+1){	outString * (branchNames[h] + "," + summaryMatrix[h][0]+ "," + summaryMatrix[h][1]+ "," + summaryMatrix[h][2]+ "," + summaryMatrix[h][5]+ "," + summaryMatrix[h][3]+"," + summaryMatrix[h][4]+"\n");	if (h%2)	{		outString2 * ("<TR CLASS = 'TRReport2'>");	}	else	{		outString2 * ("<TR CLASS = 'TRReport1'>");	}	if (summaryMatrix[h][4]>=0.95)	{		outString2 * ("<TD ALIGN = 'LEFT'><b>"+branchNames[h]+"</b></TD><TD>"+Format (summaryMatrix[h][0],10,3)+"</TD><TD>"+Format (summaryMatrix[h][1],10,3)+"</TD><TD>"+Format (summaryMatrix[h][2],10,3)+"</TD><TD>"+Format (summaryMatrix[h][5],10,3)+"</TD><TD>"+					  	 Format (summaryMatrix[h][3],10,3)+"</TD><TD><b>"+Format (summaryMatrix[h][4],10,3)+"</b></TD></TR>\n");	}	else	{		outString2 * ("<TD ALIGN = 'LEFT'>"+branchNames[h]+"</TD><TD>"+Format (summaryMatrix[h][0],10,3)+"</TD><TD>"+Format (summaryMatrix[h][1],10,3)+"</TD><TD>"+Format (summaryMatrix[h][2],10,3)+"</TD><TD>"+Format (summaryMatrix[h][5],10,3)+"</TD><TD>"+					  	 Format (summaryMatrix[h][3],10,3)+"</TD><TD>"+Format (summaryMatrix[h][4],10,3)+"</TD></TR>\n");		}}outString * 0;outString2 * 0;fName2 = fPath + ".csv";fprintf (fName2, CLEAR_FILE,outString);fprintf (fName, "<DIV CLASS = 'RepClassSM'>Model Averaged Branch dN/dS<p>Branches with high model-averaged support for dN&gt;dS are shown in <b>bold</b><p><TABLE BORDER = '0' WIDTH = '100%'>",outString2,"</TABLE>",				 "<font size = '-1'><br>&#134; Note: not a p-value!</font></DIV>");fprintf (fName, "</body></html>", CLOSE_FILE);branchColors  = {};branchLabels  = {};branchRates   = {};branchLengths = {};branchColors [0] = {{0,128,0}}*(1/255);   		/* clover */branchColors [1] = {{255,0,0}}*(1/255); 		/* red */branchColors [2] = {{64,0,128}}*(1/255); 		/* eggplant */branchColors [3] = {{0,0,255}}*(1/255);   		/* blue */branchColors [4] = {{200,200,200}}*(1/255);   	/* light gray */fprintf (stdout, "\n\n[PHASE 5] Making a PostScript tree plot\n");TREE_OUTPUT_OPTIONS = {};tree_lng = BranchLength (analysisTree,-1);totalTreeLength = 0;iNodeCounter = 1;for (k=0; k<Columns(branchNames)-1; k=k+1){	nodeSpec  = {};	nodeName  = branchNames [k]&&1;	nodeLabel = branchLabels[nodeName];	if (Abs(nodeLabel))	{		nodeSpec ["TREE_OUTPUT_BRANCH_LABEL"] = "("+nodeLabel+") show";	}	else	{		if (nodeName/"NODE*")		{			nodeSpec ["TREE_OUTPUT_BRANCH_LABEL"] = "__FONT_SIZE__ 3 idiv -__FONT_SIZE__ 3 idiv rmoveto\n("+nodeName+") show";			iNodeCounter = iNodeCounter + 1;		}	}	nodeRate  = bestModel[k];	nodeColor = branchRates[nodeRate];	if (Abs(nodeColor) == 0)	{		branchRates[nodeRate] = Abs(branchRates)+1;	}	nodeColor = branchRates[nodeRate]-1;	branchLengths [nodeRate] = branchLengths [nodeRate] + tree_lng[k];	totalTreeLength = totalTreeLength + tree_lng[k];	nodeSpec ["TREE_OUTPUT_BRANCH_COLOR"] = branchColors[nodeColor];	nodeSpec ["TREE_OUTPUT_OVER_BRANCH"] = "0 0 0 setrgbcolor\n5 5 rmoveto\n("+Format(summaryMatrix[k][4]*100,0,1)+"\\%) show";	nodeName  = branchNames [k];	TREE_OUTPUT_OPTIONS[nodeName] = nodeSpec;}TREE_OUTPUT_OPTIONS["__FONT_SIZE__"] = 16;baseHeight = TipCount (analysisTree)*48;psString = PSTreeString (analysisTree,"",{{612,baseHeight}});psLegend = "";psLegend * 256;bKeys = Rows (branchRates);sortedKeys = {Abs(branchRates),2};for (k=0; k<Abs(branchRates); k=k+1){	sortedKeys[k][0] = 0+bKeys[k];	sortedKeys[k][1] = k;}	sortedKeys = sortedKeys%0;currentPosY = baseHeight + 10;currentPosX = 25;for (k=0; k<Abs(branchRates); k=k+1){	ks = sortedKeys[k][1];	theKey = bKeys[ks];	aKey = branchRates[theKey]-1;	colorMx = branchColors[aKey];	psLegend * (""+colorMx[0]+" "+colorMx[1]+" "+colorMx[2]+ " setrgbcolor\n"+currentPosX+" "+currentPosY+" moveto\n");	psLegend * ("(dN/dS = "+Format(0+bKeys[ks],6,3)+"; "+Format(branchLengths[theKey]/totalTreeLength*100,4,0)+ "\\%) show\n");	currentPosY = currentPosY + 20;}newHeight = baseHeight + 20 + Abs(branchRates)*20;psLegend * "showpage";psLegend * 0;repMx = {{"showpage"}{psLegend}};psString = psString ^ repMx;repMx = {{"/PageSize\\ \\[[0-9\\ ]+\\]"}{"/PageSize [612 "+ newHeight+ "]"}};psString = psString ^ repMx;repMx = {{"setfont"}{"setfont\n3 setlinewidth\n1 setlinecap"}};psString = psString ^ repMx;fName = fPath + ".ps";fprintf (fName, CLEAR_FILE,psString);fName = fPath + ".branch_classes";fprintf (fName, CLEAR_FILE,convertMatrixToBranchPart (bestModel));